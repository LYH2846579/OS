PCB -> 作为进程控制块(为进程的一个私有属性)
Process -> 进程类,其内部有一私有属性为PCB,且拥有一些方法[申请资源、释放资源、进入阻塞状态、删除、运行状态]
RCB -> 作为资源控制块(作为资源的一个私有属性)
Resource -> 资源类,其内部有一私有属性为RCB,且拥有一些分配方法




状态转换与调度分析
(1) 当我们创建一个进程的时候，它会没有待申请的资源，因此默认状态为"Ready" -> 默认被加入Ready中
(2) 我们可以(静态)申请资源，这时候意味着，我们要判断其申请的资源是否处于free状态，
        ->倘若处于free状态，则就将其加入Readylist中
        ->倘若不处于free状态，就要将其加入Blockedlist中，并从原来的Readlist中删除!
    关于动态申请资源 -> 与静态申请类似，但是需要考虑调度问题!



接下来待解决的问题 -> 运行完毕的程序存储问题
                -> 解决运行完毕的程序居然出现在Readylist中的情况
                -> 转换为Running状态的队列居然还存在与Readylist中!
                -> Readylist中进程重复的问题


针对于HashMap的遍历:map.foreach((k,v) -> { ... })     !!!

关于挂起的状态
    -> 当一个进程动态申请内存，发现内存不足的时候，此时CPU将该申请内存的进程挂起(释放其拥有的所有内存)
    -> 当有进程执行完毕的时候，内存会被释放，此时遍历被阻塞的进程，若发现有进程所需要的内存空间小于已有的内存空间
    -> 则将其从外存中纳入内存  --> 这就意味着需要一个存储进程对应内存的序列->使用IdentifyHashMap即可实现
    -> 这里为CPU分配工作内存空间为512 -> 这里不妨在构造器中就硬性设置

针对于内存操作中恢复挂起的状态
    -> AtomicInteger的使用
    -> 当一个进程从挂起状态被恢复的时候，存在两种可能性
        -> (1) 没有需要的资源被其他资源所占用 --> 因此可以直接放入Readylist之中
           (2) 当被其他资源所阻塞的时候 -> 将其加入Blockedlist之中


待解决的问题 21.11.7.23:55
    -> 唤醒被挂起的进程是会存在处于两个list中!!!!!!                                      √
    -> 资源重复申请问题 //注意注意 -> 必须保证资源不会被重复申请!!!!                        √
    -> 有关于单步测试环节，需要判断runninglist中是否已经存在资源（否则就执行资源调度）         √
        -> 否则就直接单步执行

待解决的问题
    -> 连续运行的时候陷入死循环的问题!!        -> 即当没有创建过进程的时候,不断显示当前无进程正在运行   -> √
    -> 注意！ 当一个进程执行完毕的时候，将其从Process中除名?   -> 还是保留着比较好(方便观察)   √
    -> 注意! 倘若资源已经处于其申请队列之中！又再一次申请时怎么办？                          √
    -> 注意! 倘若进程已经被运行完毕，再对其执行申请资源、申请内存等该如何处理?                 √
    -> ConcurrentModificationException!     在阻塞队列中的进程取出执行的时候发生!             [三层制约关系中]
        Exception in thread "main" java.util.ConcurrentModificationException
        	at java.util.LinkedList$ListItr.checkForComodification(LinkedList.java:966)
        	at java.util.LinkedList$ListItr.next(LinkedList.java:888)
        	at exp2.CtrlBlock.release(CtrlBlock.java:571)
        	at exp2.CPU.main(CPU.java:67)
       --> 分析后发现为该进程申请到对应的资源之后，仍然处于该资源的阻塞队列中!
       ---> 进一步debug发现是因为两次申请的资源被加入到一个资源的阻塞队列中!!  -> 其实是每一次遍历resourceR导致
            不妨强制使其执行一次之后就退出循环，还要求每一次的资源申请必须执行头插

    -> 申请资源的时候倘若输入一个不正确的PID会导致NullPointerException！                 -> 添加空指针校验模块
    -> 目前运行时间无法修改的问题                                                     -> √


目前待解决的问题:
    -> 资源申请出现死锁的问题!         DeadLock
        处理方案为选择一个优先级最低的进程，释放其所拥有的资源(当然要将这些资源加入到该进程未拥有的资源队列中).
        并为释放的每一个资源重新分配所属的进程。 -> 类似release()中的操作

    -> 如何判断出现了死锁?   当runninglist和readylist中无进程存在的时候，且Blockedlist中有进程存在!
    -> 这里又涉及到一些问题!
        --> 挂起的时候是否需要释放其所拥有的所有资源?   yes!        ->增加解决机制    www
        --> 这里在挂起的时候需要释放资源，在处理死锁问题的时候也需要释放资源，不妨在实现一个资源分配的处理方法
        --> 注意!这里由于挂起的程序也加入的资源申请        --> 感觉这样确实不妥，分析一下

        分析：
            将进程挂起的时候，释放其拥有的每一个资源时，若将该进程加入收资源阻塞的列表，会出现一些问题。如在一个进程运行完毕的时候释放资源，
        发现资源阻塞队列的第一个进程就是该被挂起的进程，所以不可以分配给他...
            那咋办? 想法就是不加进去，等着以后内存充足被唤醒了(唤醒部分要处理一下，再写一个解决方法)，首先进行资源申请(这次是针对要遍历资源申请序列)，
        ，若多个资源未申请到就被迫加入多个资源的阻塞队列中。
            此时针对死锁的情况，反正是都处在Blockedlist中，抓取一个优先级最小的进程加以释放其资源(当然也要记录下其拥有的资源列表)，此时其仍处于
        Blockedlist中，要是有其他进程运行结束之后分配资源，该进程也可以获取到。

    -> for循环在执行的过程之中操作的对象不允许被修改!         --> 有无好的解决方案?












测试集:
[1] 当无资源时运行/debug                                            -> √
[2] 创建两个进程，优先级相同/不同，并直接运行                           -> √
[3] 创建三个进程A,B,C,优先级分别为1,2,3.                             -> √
    首先单步执行一次(C会被执行一个时间片),接下来A申请资源11，
    B申请资源12，C申请资源11(被阻塞)，申请资源12(仍被阻塞)，
    接下来顺序执行.



















