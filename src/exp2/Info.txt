PCB -> 作为进程控制块(为进程的一个私有属性)
Process -> 进程类,其内部有一私有属性为PCB,且拥有一些方法[申请资源、释放资源、进入阻塞状态、删除、运行状态]
RCB -> 作为资源控制块(作为资源的一个私有属性)
Resource -> 资源类,其内部有一私有属性为RCB,且拥有一些分配方法




状态转换与调度分析
(1) 当我们创建一个进程的时候，它会没有待申请的资源，因此默认状态为"Ready" -> 默认被加入Ready中
(2) 我们可以(静态)申请资源，这时候意味着，我们要判断其申请的资源是否处于free状态，
        ->倘若处于free状态，则就将其加入Readylist中
        ->倘若不处于free状态，就要将其加入Blockedlist中，并从原来的Readlist中删除!
    关于动态申请资源 -> 与静态申请类似，但是需要考虑调度问题!



接下来待解决的问题 -> 运行完毕的程序存储问题
                -> 解决运行完毕的程序居然出现在Readylist中的情况
                -> 转换为Running状态的队列居然还存在与Readylist中!
                -> Readylist中进程重复的问题


针对于HashMap的遍历:map.foreach((k,v) -> { ... })     !!!

关于挂起的状态
    -> 当一个进程动态申请内存，发现内存不足的时候，此时CPU将该申请内存的进程挂起(释放其拥有的所有内存)
    -> 当有进程执行完毕的时候，内存会被释放，此时遍历被阻塞的进程，若发现有进程所需要的内存空间小于已有的内存空间
    -> 则将其从外存中纳入内存  --> 这就意味着需要一个存储进程对应内存的序列->使用IdentifyHashMap即可实现
    -> 这里为CPU分配工作内存空间为512 -> 这里不妨在构造器中就硬性设置

针对于内存操作中恢复挂起的状态
    -> AtomicInteger的使用
    -> 当一个进程从挂起状态被恢复的时候，存在两种可能性
        -> (1) 没有需要的资源被其他资源所占用 --> 因此可以直接放入Readylist之中
           (2) 当被其他资源所阻塞的时候 -> 将其加入Blockedlist之中


待解决的问题 21.11.7.23:55
    -> 唤醒被挂起的进程是会存在处于两个list中!!!!!!                                      √
    -> 资源重复申请问题 //注意注意 -> 必须保证资源不会被重复申请!!!!                        √
    -> 有关于单步测试环节，需要判断runninglist中是否已经存在资源（否则就执行资源调度）         √
        -> 否则就直接单步执行

待解决的问题
    -> 连续运行的时候陷入死循环的问题!!



























